# -*- coding: utf-8 -*-
"""Test 2 Corrected.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-J_ozQtvZP54nCGGAhMaGJhlwmsKreDA
"""

#Install packages
!pip install scanpy

!pip install anndata

!pip3 install igraph

!pip install celltypist

!pip install decoupler

!pip install fa2-modified

# Core libraries
import scanpy as sc
import anndata as ad
import decoupler as dc
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

#Import data using wget
! wget https://github.com/josoga2/sc/raw/refs/heads/main/bone_marrow.h5ad

#Read dataset
bone_adata = sc.read_h5ad('bone_marrow.h5ad')
print(bone_adata)

#Check shape of data
bone_adata.shape #dimensions of the dataset

#14783 cells
#17374 genes
bone_adata.var.head() #overview of the rows describing the genes in the dataset

#check obs
bone_adata.obs.head()

bone_adata.obs_keys()

bone_adata.uns_keys()

#Make var and obs unqiue
bone_adata.var_names_make_unique()
bone_adata.obs_names_make_unique()

#check var
bone_adata.var

bone_adata.var_names

def annotate_qc_features(adata):
    """Annotate mitochondrial, ribosomal, and hemoglobin genes."""
    adata.var['MT'] = adata.var_names.str.startswith("MT-")
    adata.var['RIBO'] = adata.var_names.str.startswith(("RPS", "RPL"))
    adata.var['HB'] = adata.var_names.str.startswith("^HB[^(P)]")
    sc.pp.calculate_qc_metrics(
        adata, qc_vars=["MT", "RIBO", "HB"], inplace=True, log1p=True
    )
    return adata

bone_adata = annotate_qc_features(bone_adata)

#bone_adata.var['MT'] = bone_adata.var_names.str.startswith("MT-")
#bone_adata.var['RIBO'] = bone_adata.var_names.str.startswith(("RPS", "RPL"))
#bone_adata.var['HB'] = bone_adata.var_names.str.startswith("^HB[^(P)]")

#sc.pp.calculate_qc_metrics(
    #bone_adata, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
#)

import matplotlib.pyplot as plt

plt.rcParams["figure.figsize"] = (5,4)  # Adjust figure size
plt.rcParams["axes.grid"] = True  # Add grid to plots
plt.rcParams["axes.edgecolor"] = "black" # Set plot border color
plt.rcParams["axes.linewidth"] = 1.5 # Set plot border width
plt.rcParams["axes.facecolor"] = "white" # Set background color
plt.rcParams["axes.labelcolor"] = "black" # Set label color
plt.rcParams["xtick.color"] = "black" # Set x-axis tick color
plt.rcParams["ytick.color"] = "black" # Set y-axis tick color
plt.rcParams["text.color"] = "black" # Set text color

#QC Visualization
sc.pl.violin(
    bone_adata,
    ["n_genes_by_counts", 'total_counts', 'pct_counts_MT'],
    jitter=0.4,
    multi_panel=False,
)

#Scatter plot
sc.pl.scatter(
    bone_adata,
    x="total_counts",
    y="n_genes_by_counts",
    color="pct_counts_MT"
)

#The number of genes expressed in each cell
sc.pl.violin(
    bone_adata,
    ["n_genes_by_counts"],
    jitter=0.4,
    multi_panel=False,
)

sc.pp.filter_cells(bone_adata, min_genes=200)
sc.pp.filter_genes(bone_adata, min_cells=3)
bone_adata = bone_adata[bone_adata.obs['pct_counts_MT'] < 10, :] # Remove cells with >10% MT counts

#Normalization
bone_adata.layers["counts"] = bone_adata.X.copy()
sc.pp.normalize_total(bone_adata)
sc.pp.log1p(bone_adata)

#Feature Selection
#Highly variable genes capture cell identity differences
sc.pp.highly_variable_genes(bone_adata, n_top_genes=1000)
sc.pl.highly_variable_genes(bone_adata) #plot of highly variable genes

#Dimensionality Reduction
#PCA reduces noise before clustering
sc.tl.pca(bone_adata)

sc.pl.pca_variance_ratio(bone_adata, n_pcs=10, log=False)

#Checking the Nearest Neighbor
sc.pp.neighbors(bone_adata)
sc.tl.umap(bone_adata)

bone_adata

#Clustering
# Leiden clustering is used to identify transcriptionally distinct immune populations.
# Resolution = 1.0 balances over-clustering vs biologically interpretable groups.
sc.tl.leiden(bone_adata, flavor="igraph", n_iterations=2, key_added="leiden_res_", resolution=1.0)

sc.pl.umap(
    bone_adata,
    color=["leiden_res_"],
    size=32,
    ncols = 1
)

#fix data for cell annotation
## Map PanglaoDB marker gene symbols to Ensembl gene IDs using BioMart to ensure identifier compatibility with the scRNA-seq dataset and enable accurate cell type enrichment scoring.
!wget wget -O result.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "CSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "hsapiens_gene_ensembl" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "external_gene_name" /></Dataset></Query>'

import pandas as pd

ensembl_var = pd.read_csv('result.txt', header = None)

ensembl_var.columns = ['ensembl_gene_id', 'gene_name']

ensembl_var.head(3)

#cell annotation
import decoupler as dc

# Query Omnipath and get PanglaoDB
markers = dc.op.resource(name="PanglaoDB", organism="human")

# Keep canonical cell type markers alone
#markers = markers[markers["canonical_marker"]]

# Remove duplicated entries
markers = markers[~markers.duplicated(["cell_type", "genesymbol"])]

#Format because dc only accepts cell_type and genesymbol

markers = markers.rename(columns={"cell_type": "source", "genesymbol": "target"})
markers = markers[["source", "target"]]


markers.head()

#correct target to ensemble
markers = markers.merge(ensembl_var, left_on="target", right_on="gene_name", how="left")
markers = markers.drop(columns=["target"])
# Remove duplicated entries
markers = markers[~markers.duplicated(["source", "ensembl_gene_id"])]

#Format because dc only accepts cell_type and genesymbol
markers = markers.rename(columns={"source": "source", "ensembl_gene_id": "target"})

markers = markers[["source", "target"]]
markers = markers.dropna()

markers.head()

bone_adata.var_names

dc.mt.ulm(data=bone_adata,
          net=markers,
          tmin = 3)

score = dc.pp.get_obsm(bone_adata, key="score_ulm")
score

bone_adata.obsm["score_ulm"].head()

bone_adata.obsm["score_ulm"].columns

#rank genes
bone_adata_gene_rank = dc.tl.rankby_group(score, groupby="leiden_res_", reference="rest", method="t-test_overestim_var")
bone_adata_gene_rank = bone_adata_gene_rank[bone_adata_gene_rank["stat"] > 0]
bone_adata_gene_rank.head(5)

#top cell type per cluster
top_cell_type_per_group = bone_adata_gene_rank.groupby('group')['name'].apply(lambda x: x.head(1))
display(top_cell_type_per_group.to_dict())

#check the score for one of the cell types, Neutrophils
sc.pl.umap(score, color=["Neutrophils","leiden_res_"], cmap="RdBu_r")

#check the score for one of the cell types, monocyte
sc.pl.umap(score, color=["Monocytes","leiden_res_"], cmap="RdBu_r")

#create a dictionary with cell type
dict_ann = bone_adata_gene_rank[bone_adata_gene_rank["stat"] > 0].groupby("group").head(1).set_index("group")["name"].to_dict()
dict_ann

# Append cluster IDs to predicted cell type labels to preserve original Leiden cluster identity while assigning biologically interpretable annotations
new_dict_ann = {k: f"{v}_{k}" for k, v in dict_ann.items()}
bone_adata.obs["leiden_res_"] = bone_adata.obs["leiden_res_"].cat.rename_categories(new_dict_ann)

#generate plot of cell type
sc.pl.umap(
    adata=bone_adata,
    color=[ "leiden_res_"],
    ncols=1,
)

#trajectory analysis
sc.tl.draw_graph(bone_adata)

plt.rcParams["figure.figsize"] = (4,4)
sc.pl.draw_graph(bone_adata, color='leiden_res_', size = 16)

#Abstract the graph
#all the points that cluster to make one cell type, will be converted to one point
#More like a blunt summary of everypoint
sc.tl.paga(bone_adata, groups='leiden_res_')

sc.pl.paga(bone_adata, color=['leiden_res_'])

plt.rcParams["figure.figsize"] = (5,4)
sc.pl.paga_compare(bone_adata, threshold=0.03, frameon=True, edges=True, size = 16)

import numpy as np
sc.tl.diffmap(bone_adata)
bone_adata.uns['iroot'] = np.flatnonzero(bone_adata.obs['leiden_res_']  == 'B cells naive_6')[0]
sc.tl.dpt(bone_adata)

sc.pl.draw_graph(bone_adata, color=['dpt_pseudotime', 'leiden_res_'], legend_loc='on data', size = 24)

bone_adata.write("bone_adata.h5", compression="gzip")